title: Bitcrushing with Web Audio in JavaScript
---
author: alex
---
pub_date: 2021-01-08
---
last_updated: 2021-01-08
---
tags:
web audio
bit-crusher
---
_hidden: false
---
short_text: Making your audio sound like trash. In a good way!
---
body:

Bitcrushing crept up on me.  For a long time, I thought it wasn't interesting because I wasn't making 8-bit video game soundtracks or chiptune music.  But then I bought the dreamy and desolate [Fez Soundtrack](https://music.disasterpeace.com/album/fez-ost), which is something of a masterclass in bitcrushing.  I also heard Deerhoof's ["Sexy But Sparkly"](https://famousclass.bandcamp.com/track/deerhoof-sexy-but-sparkly).  At that point I knew I was wrong: bitcrushing could be forward-looking, a tool versatile enough to evoke digital desolation or add a satisfying crunch to a bass guitar line. 

### How is Sound Digitized?

Before we dive into bitcrushing -- a strictly digital process -- let's cover the mechanics behind sound and how it is represented digitally. According to Gareth Loy, author of *Musimathics*, when you strike a tuning fork, "what you hear is a result of the periodic changes in air pressure at your eardrum caused by the vibration of the air set in motion" [1].

Sound is converted from the analog domain to the digital domain by a transducer like a microphone or a guitar pickup which that converts the air pressure fluctuations into electrical signal. Once converted to electricity, which is not yet digital, an analog-to-digital converter, or ADC, can then take snapshots at a some consistent rate to represent the momentary amplitude of the analog signal.  The rate at which the samples are taken is called the [sample rate](https://en.wikipedia.org/wiki/Sampling_%28signal_processing%29), and the numeric depth of the amplitude readings is the [bit depth](https://en.wikipedia.org/wiki/Audio_bit_depth) which expresses the quantity and sign of a reading.

### Bit-Reduction and Downsampling 

I've taken a short audio clip of some piano playing and experimented with Logic Pro's Bitcrusher, adjusting the bit depth and the downsampling factor. Here is the clip with no bit-crushing.  

<audio controls src="/static/audio/bitcrusher-24bits-1x-downsampling.mp3"></audio>

And the visualization from the Logic Pro bitrcusher interface.

![the test file with no bitcrushing applied](/static/img/bitcrusher-24bit-1x.png)

Notice that the resolution is set to 24-bits and the downsampling is set to a factor of one.  That more or less leaves the sound alone, as the file is already 24-bit, and doing anything by a factor of one will have no effect.

Before we start to manipulate the sample, it's worth noting that there are two ways to bitcrush an audio stream and they can be used in conjunction. The first is bit-reduction, which means quantizing the amplitude values in the stream to a bit-depth lower than the source stream. This reduces the potential range of amplitude values but keeps the sample count constant. An amplitude reading in a 24-bit sample can be one of 2^24 values, ranging from  -2^23 to 2^23 - 1.  Likewise, in a 4-bit sample, a given amplitude reading can be any of 2^4 possible values, ranging from -16 to 15. 

After reducing the test clip from 24 to 4 bits, which is a reduction in possible values from 16777216 to 16, you get an audio file that sounds like this:
 
<audio controls src="/static/audio/bitcrusher-4bits-1x-downsampling.mp3"></audio>

Notice how the curve changed from smooth to stepped:

![the test file reduced to 4-bits, no downsampling](/static/img/bitcrusher-4bit-1x.png)

If you squint and count carefully, you'll see that the wave on each side of the x-axis has 16 steps, which is 2 to the power of our current bit-depth, 4.

So that was just the first method, bit-reduction, which works on the *value at each sample*.

The second method of bitcrushing is downsampling, or reducing the signal stream to every nth sample, giving an approximation of the stream at a less frequent rate. 

Here is the original test file at its original 24-bit bitrate, but excessively downsampled by a factor of 40: 

<audio controls src="/static/audio/bitcrusher-24bits-40x-downsampling.mp3"></audio>

The sample rate of the sound file is 44,100 hz, which means each second of sound is comprised of 44,100 audio samples. The effect of downsample bitcrushing the file by 40x, in the case above, is to retain every 40th sample and discard the rest, which would result in roughly 1100 samples.

![the test file reduced to 4-bits, no downsampling](/static/img/bitcrusher-24bit-40x.png)

## Implementing A Bitcrusher in JavaScript

Here's a fully-functioning example of what we're going to build:

<div class="bitcrusher-demo">
  <style scoped>
    .bitcrusher-demo {
      padding: 20px;
      border-radius: 10px;
      border: 2px lightgray solid;
      width: fit-content;
    }
    .bitcrusher-demo div {
      padding: 10px 0px;
    }
    div.source-selector > label {
      display: inline-block;
    }
    input {
      display: block;
    } 
    label {
      display: block;
    }
    label > span,
    label > input {
      display: inline-block;
    }
  </style>
  <div class="effect-controls">
    <h1>Bitcrusher Demo</h1>
    <div class="source-selector">
      <label>sine <input value="sine" type="radio" name="source-selector" checked /> </label>
      <label>square <input value="square" type="radio" name="source-selector"  /></label>
      <label>sawtooth <input value="sawtooth" type="radio" name="source-selector"  /></label>
      <label>audio clip <input value="audio" type="radio" name="source-selector"  /></label>
    </div>
    <label>
      <span>volume</span>
      <input name="volume" type="range" min="0.0" max="0.7" step="0.05" />
    </label>
    <label>
      <span>bit depth</span>
      <input name="bits" type="range" min="1" max="16" step="1" />
    </label>
    <label>
      <span>downsampling</span>
      <input name="downsampling" type="range" min="1" max="40" step="1" />
    </label>
  </div>
  <div class="transport-controls">
    <button name="start">start</button>
    <button name="stop">stop</button>
    <button name="info">info</button>
  </div>
  <script src="app.js"></script>
</div>

Because audio programming involves both real-time performance demands and computationally intensive processing, we want to isolate the performance-sensitive code in a separate CPU thread that doesn't have to share resources with other important, thread-blocking web processes like UI events, network calls and generally synchronous code. The Web Audio API provides the `AudioWorklet` interface to do just this: we can define low-level processing code that reads the input channels' arrays of audio samples, processes them, and writes them out to the output channels' respective output arrays.

Because there are several valid ways to approach building a custom `AudioNode`, let's let's briefly state the process.

In our custom processing code we will:

- scaffold the low-level processing code class
- register the custom processing class with its thread environment
- implement the actual bitcrushing by writing the `AudioWorkletProcessor.process` and `AudioWorkletProcessor.parameterDescriptor` class methods
- understand the different types of custom `AudioParam`s

And then in our app code, we will:

- create an `audioContext`
- register the custom processing module by filename with the `audioContext`
- create our bitcrusher custom audio node by creating an instance of the `AudioWorkletNode` class with our bitcrushing parameters (bit-depth and downsampling) as options
- connect our custom bitcrusher to the rest of the audio graph
- implement a user interface with events that allow a user to manipulate the bitcrusher in real-time 


## Building the Bitcrusher

Let's create a new file called `bitcrusher.js` and  extend the `AudioWorkletProcessor` class with some empty methods.

```javascript

  // bitcrusher.js

  class BitCrusher extends AudioWorkletProcessor {
    static get parameterDescriptor () {
      // define parameters to be initialized when our processor
      // we can then access them from our bitcrusher instance in the app code (the main thread)
    } 

    process(inputs, outputs, parameters) {
      // required when extending the AudioWorkletProcessor class
    }

  }

  // make the audio thread aware of our custom processor
  // so the main thread can access it

```

finally, let's register the custom processor with the audio thread.

```javascript
  // at the bottom of bitcrusher.js
  registerProcessor('bitcrusher', BitCrusher)
```


Now that we have a complete scaffold of our audio-thread module, let's dive straight into the bitcrushing algorithm in the `process` method. 

What are we working with in terms of arguments to `process`?  

- `inputs`: a triply-nested array containing the sample data for all input nodes and their constitutive channels. Accessing a sample at `sampleIndex` would look something like this: `inputs[inputNode][channel][sampleIndex]`
- `outputs`: a triply-nested array with the same structure as `inputs` but whose sample values are all initialized to 0.  A direct copy of each input's channel sample to the same output's channel sample index would simply pass the signal untouched to next audioNode in the graph.  If you were to simply not write data to the output arrays, the output to the next node in the audio graph would be silent, as each value would be the untouched default of 0.
- `parameters`: an object with strings naming the parameter name and an array of values indicating the parameter values.  The value array  will have either length 1 or 128, depending on whether it's an `a-rate` or `k-rate` paramter.

```javascript
  // bitcrusher.js

  process(inputs, outputs, parameters) {

    const input = inputs[0]
    const output = outputs[0]
    const bits = parameters.bitDepth[0]
    const downsampling = parameters.downsampling[0]

    for (let channelIndex = 0; channelIndex < output.length; ++channelIndex) {
      for (let sampleIndex = 0; sampleIndex < output[channelIndex].length; ++sampleIndex) {

        if (!input[channelIndex]) return false

        // sample and hold: update last sample value every <downsample>th sample 
        if (sampleIndex % downsampling === 0) {
          const step = Math.pow(0.5, bits) 
          this._lastSampleValue = step * Math.floor(input[channelIndex][sampleIndex]/step)
        }

        output[channelIndex][sampleIndex] = this._lastSampleValue

      }
    }

    return true
  }

```




References: 

1. Musimathics, Vol. 1, Gareth Loy, page 1.
2. https://developers.google.com/web/updates/2017/12/audio-worklet
3. https://www.w3.org/TR/webaudio/#audioworkletnode
4. https://www.w3.org/TR/webaudio/#AudioWorklet-Examples
5. https://developer.mozilla.org/en-US/docs/Web/API/AudioWorkletProcessor/process
