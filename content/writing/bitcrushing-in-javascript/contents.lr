title: Bitcrushing with Web Audio in JavaScript
---
author: alex
---
pub_date: 2020-10-02
---
last_updated: 2017-11-16
---
tags:
web audio
bit-crusher
---
_hidden: false
---
short_text: Making your audio sound like trash. In a good way!
---
body:

Bitcrushing crept up on me.  For a long time, I thought it wasn't interesting because I wasn't making 8-bit video game soundtracks or chiptune music.  But then I bought the dreamy and desolate [Fez Soundtrack](https://music.disasterpeace.com/album/fez-ost), which is something of a masterclass in bitcrushing.  I also heard Deerhoof's ["Sexy But Sparkly"](https://famousclass.bandcamp.com/track/deerhoof-sexy-but-sparkly).  At that point I knew I was wrong: bitcrushing could be forward-looking, a tool versatile enough to evoke digital desolation or the crunch of a pop bass-line. 

### How is Sound Digitized?

Before we dive into bitcrushing -- a strictly digital process -- let's cover the mechanics behind sound and how it is represented digitally. According to Gareth Loy, author of *Musimathics*, when you strike a tuning fork, "what you hear is a result of the periodic changes in air pressure at your eardrum caused by the vibration of the air set in motion" [1].

Sound is converted from the analog domain to the digital domain by a transducer like a microphone or a guitar pickup which that converts the air pressure fluctuations into electrical signal. Once converted to electricity, which is not yet digital, an analog-to-digital converter, or ADC, can then take snapshots at a some consistent rate to represent the momentary amplitude of the analog signal.  The rate at which the samples are taken is called the **sample rate**, and the numeric depth of the amplitude readings is the **bit depth** which expresses the quantity and sign of a reading.

### Bitcrushing in Theory

I'm going to use a clip of some experimentation I did during my personal bitcrushing rennaissance in order to demonstrate the parameters and the resulting sound you would find from your typical bitcrusher.

Here it is, with no bit-crushing.  

![the test file with no bitcrushing applied](/static/img/bitcrusher-24bit-1x.png)

<audio controls src="/static/audio/bitcrusher-24bits-1x-downsampling.mp3"></audio>

Here's an audio clip and the corresponding Logic Pro Bitcrusher vizualization.  You'll notice that the resolution is set to 24-bits and the downsampling is set to a factor of one.  That more or less leaves the sound alone, as the file is already 24-bit, and doing anything by a factor of one will have no effect.

There are two ways to bitcrush an audio stream and they can be used in conjunction. The first is bit-reduction, which means quantizing the amplitude values in the stream to a bit-depth lower than the source stream. This reduces the potential range of amplitude values but keeps the sample count constant. An amplitude reading in a 24-bit sample can be one of 2^24 values, ranging from  -2^23 to 2^23 - 1.  Likewise, in a 4-bit sample, a given amplitude reading can be any of 2^4 possible values, ranging from -16 to 15. 

After reducing the test clip from 24 to 4 bits, which is a reduction in possible values from 16777216 to 16, you get an audio file that sounds like this:
 
<audio controls src="/static/audio/bitcrusher-4bits-1x-downsampling.mp3"></audio>

Notice how the curve changed from smooth to stepped:

![the test file reduced to 4-bits, no downsampling](/static/img/bitcrusher-4bit-1x.png)

If you squint and count carefully, you'll see that the wave on each side of the x-axis has 16 steps, which is 2 to the power of our current bit-depth, 4.

So that was just the first method, bit-reduction, which works on the *value at each sample*.

The second method of bitcrushing is downsampling, or reducing the signal stream to every nth sample, giving an approximation of the stream at a less frequent rate. 

Here is the original test file at its original 24-bit bitrate, but excessively downsampled by a factor of 40: 

<audio controls src="/static/audio/bitcrusher-24bits-40x-downsampling.mp3"></audio>

The sample rate of the sound file is 44,100 hz, which means each second of sound is comprised of 44,100 audio samples. The effect of downsample bitcrushing the file by 40x, in the case above, is to retain every 40th sample and discard the rest, which would result in roughly 1100 samples.

![the test file reduced to 4-bits, no downsampling](/static/img/bitcrusher-24bit-40x.png)

## A JavaScript Implementation

### The Audio Worklet

To achieve a bitcrushing effect, we need the Web Audio API's custom AudioWorklet Node. custom processes the individual amplitude of audio samples, we will need to go a little deeper than you might normally be used to with Web Audio and build a custom Audio Node.

The Audio Worklet object is bound to the Web Audio context, and provides you with a way to register and load a custom Audio Node. 

### The Bitcrushing Implimentation Logic 

In the script file containing your custom audio processing code:
  - extend the `AudioWorkletProcessor` class in the global scope, implemening the process method and making sure to call super in the constructor(). 
  - register the module with the `registerProcessor` function.

In the app code:
- Create an audio context
- Create an AudioWorkletNode (passing the audio context and the string name of the audio processing module). 
- Connect your newly instantiated node to the audioContext's `destination` output or some other node that is in the audio graph. 
- Register your processor code on the audioWorklet object (.addModule)


## Bitcrushing Examples

References: 

1. Musimathics, Vol. 1, Gareth Loy, page 1.
2. https://developers.google.com/web/updates/2017/12/audio-worklet
3. https://www.w3.org/TR/webaudio/#audioworkletnode
4. https://www.w3.org/TR/webaudio/#AudioWorklet-Examples
